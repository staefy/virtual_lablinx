<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual StackLink Simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
      color: #333;
    }

    h1 {
      color: #006699;
    }

    #device {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      margin-top: 30px;
    }

    /* Each stop in the track */
    .stop {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 6px;
      width: 80px;
    }

    /* Tower representing a stack lift */
    .tower {
      position: relative;
      width: 30px;
      height: 120px;
      background-color: #555;
      border: 2px solid #333;
      border-radius: 4px;
      margin-bottom: 2px;
      box-sizing: border-box;
    }

    /* Camera rig above a stop */
    .camera {
      width: 60px;
      height: 40px;
      background-color: #cccccc;
      border: 1px solid #888;
      border-radius: 4px 4px 0 0;
      box-sizing: border-box;
      display: none;
    }

    /* Visible camera rig */
    .camera.visible {
      display: block;
    }

    /* Active camera when the stop is ignored */
    .camera.active {
      background-color: #ffdb99;
      border-color: #d38a00;
    }

    /* Track segment where a plate may reside */
    .segment {
      position: relative;
      width: 70px;
      height: 30px;
      margin-top: 4px;
      background-color: #f7f7f7;
      border: 2px solid #888;
      border-radius: 0 0 6px 6px;
      box-sizing: border-box;
    }

    .segment.occupied {
      background-color: #dff2df;
      border-color: #6aa96a;
    }

    /* Visual representation of a plate on the track */
    .plate {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 48px;
      height: 18px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 4px;
      display: none;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      line-height: 18px;
      text-align: center;
    }

    /* Container within tower to stack plate bars */
    .stack-plates {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      width: 90%;
      height: 100%;
      overflow: hidden;
    }

    .stack-plate {
      width: 100%;
      height: 4px;
      margin-bottom: 1px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 1px;
    }

    .label {
      margin-top: 2px;
      font-size: 10px;
    }

    /* Connector piece between camera rigs */
    .connector {
      width: 20px;
      height: 20px;
      margin: 0 4px;
      background-color: #b0b0b0;
      border: 1px solid #888;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    /* Ensure the track is laid out horizontally */
    #track {
      display: flex;
      align-items: flex-end;
    }
  </style>
</head>

<body>
  <h1>Virtual StackLink Simulator</h1>
  <div id="device">
    <div id="track"></div>
  </div>

  <!-- Settings panel for injecting faults and manually placing plates -->
  <details id="settings-panel" style="margin-top:20px;">
    <summary style="font-size:16px; cursor:pointer;">Simulation Settings</summary>
    <div style="margin-top:10px;">
      <h3 style="margin-bottom:5px;">Mock Errors</h3>
      <div id="error-controls" style="font-size:14px; line-height:1.6;">
        <label><input type="checkbox" id="err-dispense_failure"> Dispense failure (2000)</label><br>
        <label><input type="checkbox" id="err-lift_blocked"> Lift blocked (2001)</label><br>
        <label><input type="checkbox" id="err-stack_full"> Stack full (2003)</label><br>
        <label><input type="checkbox" id="err-movement_blocked"> Movement blocked (57)</label><br>
        <!-- Sensor misreport has been removed from the simulation -->
      </div>
      <h3 style="margin-top:15px; margin-bottom:5px;">Manual Plate Placement</h3>
      <div id="plate-controls" style="font-size:14px;">
        <label for="plate-stop-select">Stop:</label>
        <select id="plate-stop-select" style="margin-right:5px;"></select>
        <button id="add-plate-btn" type="button">Add plate</button>
        <button id="remove-plate-btn" type="button" style="margin-left:5px;">Remove plate</button>
      </div>

      <h3 style="margin-top:15px; margin-bottom:5px;">Reset &amp; Stack Counts</h3>
      <div id="reset-controls" style="font-size:14px;">
        <button id="reset-btn" type="button" style="margin-bottom:8px;">Reset State</button><br>
        <div id="stack-inputs"></div>
        <button id="apply-stack-btn" type="button" style="margin-top:5px;">Apply</button>
      </div>
    </div>
  </details>
  <script>
    // Injected state at page load
    var initialState = __STATE_JSON__;

    function buildUI(state) {
      const config = state.config || { stops: [], connectors: [] };
      const trackDiv = document.getElementById('track');
      trackDiv.innerHTML = '';

      const stopsCfg = config.stops || [];
      const connectorsCfg = config.connectors || [];

      stopsCfg.forEach((stopCfg) => {
        const id = stopCfg.id;
        const type = stopCfg.type;
        const stopDiv = document.createElement('div');
        stopDiv.className = 'stop';
        stopDiv.dataset.id = id;
        stopDiv.dataset.type = type;

        // Tower for stack stops
        if (type === 'stack') {
          stopDiv.dataset.liftIndex = stopCfg.lift_index;
          const towerDiv = document.createElement('div');
          towerDiv.className = 'tower';
          const towerCount = document.createElement('span');
          towerCount.className = 'tower-count';
          towerCount.style.position = 'absolute';
          towerCount.style.top = '2px';
          towerCount.style.left = '50%';
          towerCount.style.transform = 'translateX(-50%)';
          towerCount.style.color = '#fff';
          towerCount.style.fontSize = '10px';
          towerCount.style.fontWeight = 'bold';
          towerDiv.appendChild(towerCount);
          const platesContainer = document.createElement('div');
          platesContainer.className = 'stack-plates';
          towerDiv.appendChild(platesContainer);
          stopDiv.appendChild(towerDiv);
        }

        // Camera rig
        const cameraDiv = document.createElement('div');
        cameraDiv.className = 'camera';
        if (type === 'camera') {
          cameraDiv.classList.add('visible');
        }
        stopDiv.appendChild(cameraDiv);

        // Track segment
        const segDiv = document.createElement('div');
        segDiv.className = 'segment';
        const plateEl = document.createElement('div');
        plateEl.className = 'plate';
        segDiv.appendChild(plateEl);
        stopDiv.appendChild(segDiv);

        // Label
        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = id;
        stopDiv.appendChild(labelDiv);
        trackDiv.appendChild(stopDiv);

        // Connectors
        if (connectorsCfg.some(c => c.after_stop == id)) {
          const connector = document.createElement('div');
          connector.className = 'connector';
          connector.textContent = '';
          trackDiv.appendChild(connector);
        }
      });
      updateUI(state);
    }

    function updateUI(state) {
      const stops = state.stops;
      document.querySelectorAll('#track .stop').forEach(stopDiv => {
        const id = stopDiv.dataset.id;
        const type = stopDiv.dataset.type;
        const stop = stops[id];
        if (!stop) return;

        const cameraDiv = stopDiv.querySelector('.camera');
        if (type === 'camera') {
          if (stop.ignored) cameraDiv.classList.add('active');
          else cameraDiv.classList.remove('active');
        }

        const segDiv = stopDiv.querySelector('.segment');
        const plateEl = segDiv.querySelector('.plate');
        if (stop.has_plate) {
          segDiv.classList.add('occupied');
          if (plateEl) {
            plateEl.style.display = 'block';
            plateEl.textContent = stop.plate_id || '';
          }
        } else {
          segDiv.classList.remove('occupied');
          if (plateEl) {
            plateEl.style.display = 'none';
            plateEl.textContent = '';
          }
        }

        if (type === 'stack') {
          const liftIndex = stopDiv.dataset.liftIndex;
          const stackInfo = state.stacks[liftIndex];
          const towerCount = stopDiv.querySelector('.tower-count');
          if (stackInfo && towerCount) {
            towerCount.textContent = stackInfo.count;
          }
          const platesContainer = stopDiv.querySelector('.stack-plates');
          if (platesContainer && stackInfo) {
            platesContainer.innerHTML = '';
            const count = stackInfo.count;
            for (let i = 0; i < count; i++) {
              const bar = document.createElement('div');
              bar.className = 'stack-plate';
              platesContainer.appendChild(bar);
            }
          }
        }
      });
    }

    function initSettingsPanel() {
      const select = document.getElementById('plate-stop-select');
      if (select && select.options.length === 0) {
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '--select stop--';
        select.appendChild(placeholder);

        const stopIds = Object.keys(initialState.stops).sort((a, b) => parseInt(a) - parseInt(b));
        stopIds.forEach(id => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = `Stop ${id}`;
          select.appendChild(opt);
        });
      }
      fetch('/api/errors')
        .then(res => res.ok ? res.json() : {})
        .then(flags => {
          Object.keys(flags).forEach(key => {
            const cb = document.getElementById('err-' + key);
            if (cb) cb.checked = !!flags[key];
          });
        })
        .catch(err => console.warn('Failed to fetch error flags', err));
      const errorContainer = document.getElementById('error-controls');
      if (errorContainer) {
        errorContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          cb.addEventListener('change', () => {
            const name = cb.id.replace('err-', '');
            const value = cb.checked;
            fetch(`/api/set_error?name=${encodeURIComponent(name)}&value=${value}`)
              .catch(err => console.warn('Failed to set error flag', err));
          });
        });
      }
      const addBtn = document.getElementById('add-plate-btn');
      const removeBtn = document.getElementById('remove-plate-btn');
      if (addBtn) {
        addBtn.addEventListener('click', () => {
          const stop = select.value;
          if (!stop) return;
          fetch(`/api/set_plate?stop=${stop}&present=true`)
            .then(() => refresh())
            .catch(err => console.warn('Failed to add plate', err));
        });
      }
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          const stop = select.value;
          if (!stop) return;
          fetch(`/api/set_plate?stop=${stop}&present=false`)
            .then(() => refresh())
            .catch(err => console.warn('Failed to remove plate', err));
        });
      }
      const resetBtn = document.getElementById('reset-btn');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          fetch('/api/reset_state')
            .then(() => {
              refresh();
              updateStackInputs();
            })
            .catch(err => console.warn('Failed to reset state', err));
        });
      }
      const applyStackBtn = document.getElementById('apply-stack-btn');
      if (applyStackBtn) {
        applyStackBtn.addEventListener('click', () => {
          const inputs = document.querySelectorAll('#stack-inputs input');
          const promises = [];
          inputs.forEach(input => {
            const liftIndex = input.dataset.liftIndex;
            const count = parseInt(input.value, 10);
            if (!isNaN(count)) {
              promises.push(fetch(`/api/set_stack?stack=${liftIndex}&count=${count}`));
            }
          });
          Promise.all(promises)
            .then(() => {
              refresh();
              updateStackInputs();
            })
            .catch(err => console.warn('Failed to set stack counts', err));
        });
      }
      refresh();
      updateStackInputs();
    }
    async function refresh() {
      try {
        const response = await fetch('/api/state');
        const data = await response.json();
        updateUI(data);
      } catch (e) {
        console.error('Failed to refresh state', e);
      }
    }
    async function updateStackInputs() {
      try {
        const response = await fetch('/api/state');
        const data = await response.json();
        const container = document.getElementById('stack-inputs');
        if (!container) return;
        if (container.innerHTML === '') {
          const liftIndices = Object.keys(data.stacks).sort((a, b) => parseInt(a) - parseInt(b));
          liftIndices.forEach(idx => {
            const div = document.createElement('div');
            div.style.marginBottom = '5px';
            const label = document.createElement('label');
            label.textContent = `Stack ${idx}: `;
            const input = document.createElement('input');
            input.type = 'number';
            input.min = '0';
            input.max = data.stacks[idx].capacity;
            input.value = data.stacks[idx].count;
            input.style.width = '50px';
            input.dataset.liftIndex = idx;
            div.appendChild(label);
            div.appendChild(input);
            container.appendChild(div);
          });
        } else {
          const inputs = container.querySelectorAll('input');
          inputs.forEach(input => {
            const idx = input.dataset.liftIndex;
            if (data.stacks[idx]) {
              input.value = data.stacks[idx].count;
            }
          });
        }
      } catch (e) {
        console.warn('Failed to update stack input values', e);
      }
    }
    buildUI(initialState);
    initSettingsPanel();
    setInterval(refresh, 1000);
  </script>
</body>

</html>