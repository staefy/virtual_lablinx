<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual StackLink Simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
      color: #333;
    }

    h1 {
      color: #006699;
    }

    #device {
      position: relative;
      display: inline-block;
      margin: 30px auto;
      background-color: #eee;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }

    #track-container {
      position: relative;
      display: flex;
      align-items: flex-end;
    }

    #track {
      display: flex;
      align-items: flex-end;
    }

    /* Overlay for animated plates */
    #plate-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* Each stop in the track */
    .stop {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 6px;
      width: 80px;
    }

    /* Tower representing a stack lift */
    .tower {
      position: relative;
      width: 32px;
      height: 180px;
      background-color: #555;
      border: 2px solid #333;
      border-radius: 4px;
      margin-bottom: 2px;
      box-sizing: border-box;
    }

    /* Camera rig above a stop */
    .camera {
      width: 60px;
      height: 40px;
      background-color: #cccccc;
      border: 1px solid #888;
      border-radius: 4px 4px 0 0;
      box-sizing: border-box;
      display: none;
    }

    .camera.visible {
      display: block;
    }

    .camera.active {
      background-color: #ffdb99;
      border-color: #d38a00;
    }

    /* Track segment */
    .segment {
      position: relative;
      width: 70px;
      height: 30px;
      margin-top: 4px;
      background-color: #f7f7f7;
      border: 2px solid #888;
      border-radius: 0 0 6px 6px;
      box-sizing: border-box;
    }

    .segment.occupied {
      background-color: #dff2df;
      border-color: #6aa96a;
    }

    /* Static Plate representation (hidden when moving) */
    .plate {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 48px;
      height: 18px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 4px;
      display: none;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      line-height: 18px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* Moving plate in overlay */
    .moving-plate {
      position: absolute;
      width: 48px;
      height: 18px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 4px;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      line-height: 18px;
      text-align: center;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      filter: brightness(1.1);
      transition: left linear;
      /* Duration set by JS */
    }

    .stack-plates {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      width: 90%;
      height: 100%;
      overflow: hidden;
    }

    .stack-plate {
      width: 100%;
      height: 3px;
      margin-bottom: 1px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 1px;
    }

    .label {
      margin-top: 2px;
      font-size: 10px;
      font-weight: bold;
      color: #666;
    }

    .connector {
      width: 20px;
      height: 20px;
      margin: 0 2px;
      background-color: #b0b0b0;
      border: 1px solid #888;
      border-radius: 4px;
      align-self: flex-end;
      margin-bottom: 15px;
    }
  </style>
</head>

<body>
  <h1>Virtual StackLink Simulator</h1>
  <div style="text-align:center;">
    <div id="device">
      <div id="track-container">
        <div id="track"></div>
        <div id="plate-overlay"></div>
      </div>
    </div>
  </div>

  <details id="settings-panel" style="margin-top:20px;">
    <summary style="font-size:16px; cursor:pointer; font-weight:bold;">Simulation Settings</summary>
    <div style="margin-top:10px; display: flex; gap: 40px; flex-wrap: wrap;">
      <div>
        <h3 style="margin-bottom:5px;">Mock Errors</h3>
        <div id="error-controls"
          style="font-size:14px; line-height:1.6; max-height: 300px; overflow-y: auto; padding-right: 10px;">
          <!-- Error controls will be populated dynamically -->
        </div>
      </div>

      <div>
        <h3 style="margin-bottom:5px;">Manual Plate Placement</h3>
        <div id="plate-controls" style="font-size:14px;">
          <label for="plate-stop-select">Stop:</label>
          <select id="plate-stop-select" style="margin-right:5px;"></select>
          <button id="add-plate-btn" type="button">Add plate</button>
          <button id="remove-plate-btn" type="button" style="margin-left:5px;">Remove plate</button>
        </div>

        <h3 style="margin-top:15px; margin-bottom:5px;">Reset &amp; Stack Counts</h3>
        <div id="reset-controls" style="font-size:14px;">
          <button id="reset-btn" type="button"
            style="margin-bottom:8px; background: #cc3333; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Reset
            Entire Device</button><br>
          <div id="stack-inputs"></div>
          <button id="apply-stack-btn" type="button" style="margin-top:5px;">Apply Counts</button>
        </div>
      </div>
    </div>
  </details>

  <script>
    var initialState = __STATE_JSON__;
    var activeMoveElements = {}; // plate_id -> element
    var lastState = null;

    function buildUI(state) {
      const config = state.config || { stops: [], connectors: [] };
      const trackDiv = document.getElementById('track');
      trackDiv.innerHTML = '';

      const stopsCfg = config.stops || [];
      const connectorsCfg = config.connectors || [];

      stopsCfg.forEach((stopCfg) => {
        const id = stopCfg.id;
        const type = stopCfg.type;
        const stopDiv = document.createElement('div');
        stopDiv.className = 'stop';
        stopDiv.id = 'stop-' + id;
        stopDiv.dataset.id = id;
        stopDiv.dataset.type = type;

        if (type === 'stack') {
          stopDiv.dataset.liftIndex = stopCfg.lift_index;
          const towerDiv = document.createElement('div');
          towerDiv.className = 'tower';
          const towerCount = document.createElement('span');
          towerCount.className = 'tower-count';
          towerCount.style.position = 'absolute';
          towerCount.style.top = '2px';
          towerCount.style.left = '50%';
          towerCount.style.transform = 'translateX(-50%)';
          towerCount.style.color = '#fff';
          towerCount.style.fontSize = '10px';
          towerCount.style.fontWeight = 'bold';
          towerDiv.appendChild(towerCount);
          const platesContainer = document.createElement('div');
          platesContainer.className = 'stack-plates';
          towerDiv.appendChild(platesContainer);
          stopDiv.appendChild(towerDiv);
        }

        const cameraDiv = document.createElement('div');
        cameraDiv.className = 'camera';
        if (type === 'camera') cameraDiv.classList.add('visible');
        stopDiv.appendChild(cameraDiv);

        const segDiv = document.createElement('div');
        segDiv.className = 'segment';
        const plateEl = document.createElement('div');
        plateEl.className = 'plate';
        segDiv.appendChild(plateEl);
        stopDiv.appendChild(segDiv);

        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = id;
        stopDiv.appendChild(labelDiv);
        trackDiv.appendChild(stopDiv);

        if (connectorsCfg.some(c => c.after_stop == id)) {
          const connector = document.createElement('div');
          connector.className = 'connector';
          trackDiv.appendChild(connector);
        }
      });
      updateUI(state);
    }

    // Precise coordinate calculation using getBoundingClientRect
    function getPlateCoords(stopId) {
      const stopDiv = document.getElementById('stop-' + stopId);
      const overlay = document.getElementById('plate-overlay');
      if (!stopDiv || !overlay) return { x: 0, y: 0 };

      const segDiv = stopDiv.querySelector('.segment');
      const stopRect = segDiv.getBoundingClientRect();
      const overlayRect = overlay.getBoundingClientRect();

      return {
        x: stopRect.left - overlayRect.left + (stopRect.width / 2) - 24, // 24 is half plate width
        y: stopRect.top - overlayRect.top + (stopRect.height / 2) - 9  // 9 is half plate height
      };
    }

    function updateUI(state) {
      const stops = state.stops;
      const activeMoves = state.active_moves || {};
      const overlay = document.getElementById('plate-overlay');

      // Update static stops
      document.querySelectorAll('#track .stop').forEach(stopDiv => {
        const id = stopDiv.dataset.id;
        const type = stopDiv.dataset.type;
        const stop = stops[id];
        if (!stop) return;

        // Hide static plate if it's currently moving (as source OR dest)
        const isMoving = Object.keys(activeMoves).some(pid => {
          const m = activeMoves[pid];
          return m.source == id || m.dest == id;
        });

        const cameraDiv = stopDiv.querySelector('.camera');
        if (type === 'camera') {
          if (stop.ignored) cameraDiv.classList.add('active');
          else cameraDiv.classList.remove('active');
        }

        const segDiv = stopDiv.querySelector('.segment');
        const plateEl = segDiv.querySelector('.plate');
        if (stop.has_plate && !isMoving) {
          segDiv.classList.add('occupied');
          if (plateEl) {
            plateEl.style.display = 'block';
            plateEl.textContent = stop.plate_id || '';
          }
        } else {
          segDiv.classList.remove('occupied');
          if (plateEl) {
            plateEl.style.display = 'none';
          }
        }

        if (type === 'stack') {
          const liftIndex = stopDiv.dataset.liftIndex;
          const stackInfo = state.stacks[liftIndex];
          const towerCount = stopDiv.querySelector('.tower-count');
          if (stackInfo && towerCount) towerCount.textContent = stackInfo.count;
          const platesContainer = stopDiv.querySelector('.stack-plates');
          if (platesContainer && stackInfo) {
            platesContainer.innerHTML = '';
            for (let i = 0; i < stackInfo.count; i++) {
              const bar = document.createElement('div');
              bar.className = 'stack-plate';
              platesContainer.appendChild(bar);
            }
          }
        }
      });

      // Update Animated Overlay
      // 1. Remove elements no longer moving
      Object.keys(activeMoveElements).forEach(pid => {
        if (!activeMoves[pid]) {
          activeMoveElements[pid].remove();
          delete activeMoveElements[pid];
        }
      });

      // 2. Clear old ones if source/dest mismatch (safety)
      Object.keys(activeMoves).forEach(pid => {
        const move = activeMoves[pid];
        const el = activeMoveElements[pid];
        if (el && (el.dataset.source != move.source || el.dataset.dest != move.dest)) {
          el.remove();
          delete activeMoveElements[pid];
        }
      });

      // 3. Add/Sync elements for active moves
      Object.keys(activeMoves).forEach(pid => {
        const move = activeMoves[pid];
        let el = activeMoveElements[pid];

        // Calculate remaining time
        const now = Date.now() / 1000;
        const elapsed = now - move.start_time;
        const remaining = move.duration - elapsed;

        if (remaining <= 0) return; // Should be handled by next refresh or state change

        if (!el) {
          el = document.createElement('div');
          el.className = 'moving-plate';
          el.textContent = pid;
          el.dataset.source = move.source;
          el.dataset.dest = move.dest;

          const startCoords = getPlateCoords(move.source);
          el.style.left = startCoords.x + 'px';
          el.style.top = startCoords.y + 'px';
          el.style.transition = 'none'; // No transition for spawn

          overlay.appendChild(el);
          activeMoveElements[pid] = el;

          // Trigger transition in next frame
          setTimeout(() => {
            if (!activeMoveElements[pid]) return;
            const endCoords = getPlateCoords(move.dest);
            el.style.transition = `left ${remaining}s linear`;
            el.style.left = endCoords.x + 'px';
          }, 20);
        } else {
          // Already moving, just sync duration if it's lagging
          const currentDuration = parseFloat(el.style.transitionDuration) || 0;
          if (Math.abs(currentDuration - remaining) > 0.5) {
            const endCoords = getPlateCoords(move.dest);
            el.style.transition = `left ${remaining}s linear`;
            el.style.left = endCoords.x + 'px';
          }
        }
      });
    }

    function initSettingsPanel() {
      const select = document.getElementById('plate-stop-select');
      if (select && select.options.length === 0) {
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '--select stop--';
        select.appendChild(placeholder);

        const stopIds = Object.keys(initialState.stops).sort((a, b) => parseInt(a) - parseInt(b));
        stopIds.forEach(id => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = `Stop ${id}`;
          select.appendChild(opt);
        });
      }

      const errorContainer = document.getElementById('error-controls');
      if (errorContainer) {
        errorContainer.innerHTML = '';
        const globalErrors = [{ id: 'movement_blocked', label: 'Movement blocked (57)' }];
        globalErrors.forEach(err => {
          const lb = document.createElement('label');
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.id = 'err-' + err.id;
          lb.appendChild(cb);
          lb.appendChild(document.createTextNode(' ' + err.label));
          errorContainer.appendChild(lb);
          errorContainer.appendChild(document.createElement('br'));
          cb.addEventListener('change', () => {
            fetch(`/api/set_error?name=${encodeURIComponent(err.id)}&value=${cb.checked}`);
          });
        });

        const liftIndices = Object.keys(initialState.stacks).sort((a, b) => parseInt(a) - parseInt(b));
        liftIndices.forEach(idx => {
          const hr = document.createElement('hr');
          hr.style.margin = '10px 0';
          errorContainer.appendChild(hr);
          const stackErrors = [
            { suffix: 'dispense_failure', label: 'Dispense failure' },
            { suffix: 'lift_blocked', label: 'Lift blocked' },
            { suffix: 'stack_full', label: 'Stack full' }
          ];
          stackErrors.forEach(err => {
            const key = `${err.suffix}_${idx}`;
            const lb = document.createElement('label');
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.id = 'err-' + key;
            lb.appendChild(cb);
            lb.appendChild(document.createTextNode(` Stack ${idx}: ${err.label}`));
            errorContainer.appendChild(lb);
            errorContainer.appendChild(document.createElement('br'));
            cb.addEventListener('change', () => {
              fetch(`/api/set_error?name=${encodeURIComponent(key)}&value=${cb.checked}`);
            });
          });
        });
      }

      fetch('/api/errors').then(r => r.json()).then(flags => {
        Object.keys(flags).forEach(key => {
          const cb = document.getElementById('err-' + key);
          if (cb) cb.checked = !!flags[key];
        });
      });

      document.getElementById('add-plate-btn').addEventListener('click', () => {
        const stop = select.value;
        if (stop) fetch(`/api/set_plate?stop=${stop}&present=true`).then(refresh);
      });
      document.getElementById('remove-plate-btn').addEventListener('click', () => {
        const stop = select.value;
        if (stop) fetch(`/api/set_plate?stop=${stop}&present=false`).then(refresh);
      });
      document.getElementById('reset-btn').addEventListener('click', () => {
        if (confirm("Reset all stops and stacks?")) {
          fetch('/api/reset_state').then(() => { refresh(); updateStackInputs(); });
        }
      });
      document.getElementById('apply-stack-btn').addEventListener('click', () => {
        const inputs = document.querySelectorAll('#stack-inputs input');
        const promises = Array.from(inputs).map(i => fetch(`/api/set_stack?stack=${i.dataset.liftIndex}&count=${i.value}`));
        Promise.all(promises).then(() => { refresh(); updateStackInputs(); });
      });
      refresh();
      updateStackInputs();
    }

    async function refresh() {
      try {
        const response = await fetch('/api/state');
        const data = await response.json();
        updateUI(data);
      } catch (e) { }
    }

    async function updateStackInputs() {
      try {
        const response = await fetch('/api/state');
        const data = await response.json();
        const container = document.getElementById('stack-inputs');
        if (!container || container.innerHTML !== '') return;
        Object.keys(data.stacks).sort((a, b) => parseInt(a) - parseInt(b)).forEach(idx => {
          const div = document.createElement('div');
          div.style.marginBottom = '5px';
          div.innerHTML = `<label>Stack ${idx}: </label><input type="number" min="0" max="${data.stacks[idx].capacity}" value="${data.stacks[idx].count}" style="width:50px;" data-lift-index="${idx}">`;
          container.appendChild(div);
        });
      } catch (e) { }
    }

    buildUI(initialState);
    initSettingsPanel();
    setInterval(refresh, 500);
  </script>
</body>

</html>