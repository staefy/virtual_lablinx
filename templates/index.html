<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual StackLink Simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    h1 {
      color: #006699;
    }
    #device {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      margin-top: 30px;
    }
    /* Each stop in the track */
    .stop {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 6px;
      width: 80px;
    }
    /* Tower representing a stack lift */
    .tower {
      position: relative;
      width: 30px;
      height: 120px;
      background-color: #555;
      border: 2px solid #333;
      border-radius: 4px;
      margin-bottom: 2px;
      box-sizing: border-box;
    }
    /* Camera rig above a stop */
    .camera {
      width: 60px;
      height: 40px;
      background-color: #cccccc;
      border: 1px solid #888;
      border-radius: 4px 4px 0 0;
      box-sizing: border-box;
      display: none;
    }
    /* Visible camera rig */
    .camera.visible {
      display: block;
    }
    /* Active camera when the stop is ignored */
    .camera.active {
      background-color: #ffdb99;
      border-color: #d38a00;
    }
    /* Track segment where a plate may reside */
    .segment {
      position: relative;
      width: 70px;
      height: 30px;
      margin-top: 4px;
      background-color: #f7f7f7;
      border: 2px solid #888;
      border-radius: 0 0 6px 6px;
      box-sizing: border-box;
    }
    .segment.occupied {
      background-color: #dff2df;
      border-color: #6aa96a;
    }
    /* Visual representation of a plate on the track */
    .plate {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 48px;
      height: 18px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 4px;
      display: none;
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      line-height: 18px;
      text-align: center;
    }
    /* Container within tower to stack plate bars */
    .stack-plates {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      width: 90%;
      height: 100%;
      overflow: hidden;
    }
    .stack-plate {
      width: 100%;
      height: 4px;
      margin-bottom: 1px;
      background-color: #4a90e2;
      border: 1px solid #2c5aa0;
      border-radius: 1px;
    }
    .label {
      margin-top: 2px;
      font-size: 10px;
    }
    /* Connector piece between camera rigs */
    .connector {
      width: 20px;
      height: 20px;
      margin: 0 4px;
      background-color: #b0b0b0;
      border: 1px solid #888;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    /* Ensure the track is laid out horizontally */
    #track {
      display: flex;
      align-items: flex-end;
    }
  </style>
</head>
<body>
  <h1>Virtual StackLink Simulator</h1>
  <div id="device">
    <div id="track"></div>
  </div>

  <!-- Settings panel for injecting faults and manually placing plates -->
  <details id="settings-panel" style="margin-top:20px;">
    <summary style="font-size:16px; cursor:pointer;">Simulation Settings</summary>
    <div style="margin-top:10px;">
      <h3 style="margin-bottom:5px;">Mock Errors</h3>
      <div id="error-controls" style="font-size:14px; line-height:1.6;">
        <label><input type="checkbox" id="err-dispense_failure"> Dispense failure (2000)</label><br>
        <label><input type="checkbox" id="err-lift_blocked"> Lift blocked (2001)</label><br>
        <label><input type="checkbox" id="err-stack_full"> Stack full (2003)</label><br>
        <label><input type="checkbox" id="err-movement_blocked"> Movement blocked (57)</label><br>
        <!-- Sensor misreport has been removed from the simulation -->
      </div>
      <h3 style="margin-top:15px; margin-bottom:5px;">Manual Plate Placement</h3>
      <div id="plate-controls" style="font-size:14px;">
        <label for="plate-stop-select">Stop:</label>
        <select id="plate-stop-select" style="margin-right:5px;"></select>
        <button id="add-plate-btn" type="button">Add plate</button>
        <button id="remove-plate-btn" type="button" style="margin-left:5px;">Remove plate</button>
      </div>

      <h3 style="margin-top:15px; margin-bottom:5px;">Reset &amp; Stack Counts</h3>
      <div id="reset-controls" style="font-size:14px;">
        <button id="reset-btn" type="button" style="margin-bottom:8px;">Reset State</button><br>
        <label for="stack1-count">Stack 1:</label>
        <input id="stack1-count" type="number" min="0" max="30" style="width:50px; margin-right:10px;">
        <label for="stack2-count">Stack 2:</label>
        <input id="stack2-count" type="number" min="0" max="30" style="width:50px; margin-right:10px;">
        <button id="apply-stack-btn" type="button">Apply</button>
      </div>
    </div>
  </details>
  <script>
    // Injected state at page load
    var initialState = __STATE_JSON__;
    // Define the type of each stop on the track. This reflects the physical layout:
    // 1: empty, 2: camera, 3: stack (lift 1), 4: stack (lift 2), 5-8: cameras
    const stopTypes = {
      '1': 'empty',
      '2': 'camera',
      '3': 'stack',
      '4': 'stack',
      '5': 'camera',
      '6': 'camera',
      '7': 'camera',
      '8': 'camera'
    };
    function buildUI(state) {
      const trackDiv = document.getElementById('track');
      trackDiv.innerHTML = '';
      const stopIds = Object.keys(state.stops).sort((a, b) => parseInt(a) - parseInt(b));
      stopIds.forEach((id, idx) => {
        const type = stopTypes[id] || 'camera';
        const stopDiv = document.createElement('div');
        stopDiv.className = 'stop';
        stopDiv.dataset.id = id;
        stopDiv.dataset.type = type;
        // Tower for stack stops
        if (type === 'stack') {
          const towerDiv = document.createElement('div');
          towerDiv.className = 'tower';
          // Text label showing the number of plates
          const towerCount = document.createElement('span');
          towerCount.className = 'tower-count';
          towerCount.style.position = 'absolute';
          towerCount.style.top = '2px';
          towerCount.style.left = '50%';
          towerCount.style.transform = 'translateX(-50%)';
          towerCount.style.color = '#fff';
          towerCount.style.fontSize = '10px';
          towerCount.style.fontWeight = 'bold';
          towerDiv.appendChild(towerCount);
          // Container for visualizing plates in the stack
          const platesContainer = document.createElement('div');
          platesContainer.className = 'stack-plates';
          towerDiv.appendChild(platesContainer);
          stopDiv.appendChild(towerDiv);
        }
        // Camera rig (visible for camera stops)
        const cameraDiv = document.createElement('div');
        cameraDiv.className = 'camera';
        if (type === 'camera') {
          cameraDiv.classList.add('visible');
        }
        stopDiv.appendChild(cameraDiv);
        // Track segment
        const segDiv = document.createElement('div');
        segDiv.className = 'segment';
        // Inner plate element that will display the plate ID when present
        const plateEl = document.createElement('div');
        plateEl.className = 'plate';
        segDiv.appendChild(plateEl);
        stopDiv.appendChild(segDiv);
        // Label
        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = id;
        stopDiv.appendChild(labelDiv);
        trackDiv.appendChild(stopDiv);
        // Insert a connector between stops 6 and 7 to represent the mysterious part
        if (id === '6') {
          const connector = document.createElement('div');
          connector.className = 'connector';
          connector.textContent = '';
          trackDiv.appendChild(connector);
        }
      });
      updateUI(state);
    }
    function updateUI(state) {
      const stops = state.stops;
      // Update each stop's occupancy and camera state
      document.querySelectorAll('#track .stop').forEach(stopDiv => {
        const id = stopDiv.dataset.id;
        const type = stopDiv.dataset.type;
        const stop = stops[id];
        // Camera handling
        const cameraDiv = stopDiv.querySelector('.camera');
        if (type === 'camera') {
          if (stop.ignored) {
            cameraDiv.classList.add('active');
          } else {
            cameraDiv.classList.remove('active');
          }
        }
        // Occupancy handling and plate label
        const segDiv = stopDiv.querySelector('.segment');
        const plateEl = segDiv.querySelector('.plate');
        if (stop.has_plate) {
          segDiv.classList.add('occupied');
          if (plateEl) {
            plateEl.style.display = 'block';
            plateEl.textContent = stop.plate_id || '';
          }
        } else {
          segDiv.classList.remove('occupied');
          if (plateEl) {
            plateEl.style.display = 'none';
            plateEl.textContent = '';
          }
        }
        // Update tower visuals for stack stops
        if (type === 'stack') {
          const liftIndex = id === '3' ? '1' : '2';
          const stackInfo = state.stacks[liftIndex];
          // Update numeric count
          const towerCount = stopDiv.querySelector('.tower-count');
          if (stackInfo && towerCount) {
            towerCount.textContent = stackInfo.count;
          }
          // Update visual plate bars
          const platesContainer = stopDiv.querySelector('.stack-plates');
          if (platesContainer && stackInfo) {
            // Clear existing bars
            platesContainer.innerHTML = '';
            // Determine how many bars to show. We'll cap at capacity to avoid too many elements.
            const count = stackInfo.count;
            for (let i = 0; i < count; i++) {
              const bar = document.createElement('div');
              bar.className = 'stack-plate';
              platesContainer.appendChild(bar);
            }
          }
        }
      });
    }

    /**
     * Initialize the settings panel: populate the stop selector, fetch current error flags
     * and attach event handlers for toggles and plate placement buttons.
     */
    function initSettingsPanel() {
      // Populate stop selector if empty
      const select = document.getElementById('plate-stop-select');
      if (select && select.options.length === 0) {
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '--select stop--';
        select.appendChild(placeholder);
        for (let i = 1; i <= 8; i++) {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = `Stop ${i}`;
          select.appendChild(opt);
        }
      }
      // Fetch existing error flags to sync checkbox state
      fetch('/api/errors')
        .then(res => res.ok ? res.json() : {})
        .then(flags => {
          Object.keys(flags).forEach(key => {
            const cb = document.getElementById('err-' + key);
            if (cb) cb.checked = !!flags[key];
          });
        })
        .catch(err => console.warn('Failed to fetch error flags', err));
      // Attach change handlers to all error checkboxes
      const errorContainer = document.getElementById('error-controls');
      if (errorContainer) {
        errorContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          cb.addEventListener('change', () => {
            const name = cb.id.replace('err-','');
            const value = cb.checked;
            fetch(`/api/set_error?name=${encodeURIComponent(name)}&value=${value}`)
              .catch(err => console.warn('Failed to set error flag', err));
          });
        });
      }
      // Plate placement buttons
      const addBtn = document.getElementById('add-plate-btn');
      const removeBtn = document.getElementById('remove-plate-btn');
      if (addBtn) {
        addBtn.addEventListener('click', () => {
          const stop = select.value;
          if (!stop) return;
          fetch(`/api/set_plate?stop=${stop}&present=true`)
            .then(() => refresh())
            .catch(err => console.warn('Failed to add plate', err));
        });
      }
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          const stop = select.value;
          if (!stop) return;
          fetch(`/api/set_plate?stop=${stop}&present=false`)
            .then(() => refresh())
            .catch(err => console.warn('Failed to remove plate', err));
        });
      }

      // Reset button
      const resetBtn = document.getElementById('reset-btn');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          fetch('/api/reset_state')
            .then(() => {
              // Refresh UI and update stack inputs after reset
              refresh();
              updateStackInputs();
            })
            .catch(err => console.warn('Failed to reset state', err));
        });
      }
      // Apply stack counts button
      const applyStackBtn = document.getElementById('apply-stack-btn');
      if (applyStackBtn) {
        applyStackBtn.addEventListener('click', () => {
          const s1 = document.getElementById('stack1-count');
          const s2 = document.getElementById('stack2-count');
          const c1 = parseInt(s1.value, 10);
          const c2 = parseInt(s2.value, 10);
          const promises = [];
          if (!isNaN(c1)) {
            promises.push(fetch(`/api/set_stack?stack=1&count=${c1}`));
          }
          if (!isNaN(c2)) {
            promises.push(fetch(`/api/set_stack?stack=2&count=${c2}`));
          }
          Promise.all(promises)
            .then(() => {
              // Refresh UI and update inputs after applying new counts
              refresh();
              updateStackInputs();
            })
            .catch(err => console.warn('Failed to set stack counts', err));
        });
      }

      // Immediately fetch state to populate UI and stack count inputs once
      refresh();
      updateStackInputs();
    }
    async function refresh() {
      try {
        const response = await fetch('/api/state');
        const data = await response.json();
        updateUI(data);
        // Do not update the stack count inputs here. They should remain
        // editable by the user and will be refreshed only when explicitly
        // requested (e.g., after reset or applying counts).
      } catch (e) {
        console.error('Failed to refresh state', e);
      }
    }

    /**
     * Fetch the current stack counts from the server and populate the
     * input fields. This is called once on page load and after actions
     * that modify the stacks, such as reset or applying new counts.
     */
    async function updateStackInputs() {
      try {
        const response = await fetch('/api/state');
        const data = await response.json();
        const s1Input = document.getElementById('stack1-count');
        const s2Input = document.getElementById('stack2-count');
        if (s1Input && data.stacks && data.stacks['1']) {
          s1Input.value = data.stacks['1'].count;
        }
        if (s2Input && data.stacks && data.stacks['2']) {
          s2Input.value = data.stacks['2'].count;
        }
      } catch (e) {
        console.warn('Failed to update stack input values', e);
      }
    }
    // Build initial UI and schedule updates
    buildUI(initialState);
    // Initialize settings UI on first load
    initSettingsPanel();
    setInterval(refresh, 1000);
  </script>
</body>
</html>